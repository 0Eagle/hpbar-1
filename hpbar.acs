#library "hpbar"
#include "zcommon.acs"

#define STYLE_FULL    1
#define STYLE_MINIMAL 2

#define FULL_HUD_WIDTH  800
#define FULL_HUD_HEIGHT 600
#define FULL_HOLDTIME 0.25
#define FULL_HPBAR_X 400.0
#define FULL_HPBAR_Y 40.0
#define FULL_NAME_Y  (FULL_HPBAR_Y + 25.0)
#define FULL_INFO_Y  (FULL_NAME_Y + 12.0)

#define MINIMAL_HUD_WIDTH  1280
#define MINIMAL_HUD_HEIGHT 960
#define MINIMAL_HOLDTIME ((1.0 / 35) + 1)
#define MINIMAL_FADETIME 0.1
#define MINIMAL_HP_X 640.0
#define MINIMAL_HP_Y 500.0

#define MAX_TRACKERS 50
#define NUM_RANKINGS 10
// This should be -1, but Zandronum 2.1.2 has a bug where ACS_ExecuteAlways would send -1 as 255! WTF?!!!
#define INVALID_TID (-129)

int tracked_tids[MAX_TRACKERS];
int tracked_hps[MAX_TRACKERS];
int tracked_max_hps[MAX_TRACKERS];
str tracked_names[MAX_TRACKERS];

script "hpbar-enter" enter {
    int pn = PlayerNumber();

    while (true) {
        if (has_target()) {
            int hp = get_target_health();
            int max_hp = get_target_spawn_health();
            if (max_hp <= 0) max_hp = hp;
            if (max_hp > 0) {
                if (max_hp >= GetCVar("hpbar_server_min_maxhp")) {
                    ACS_ExecuteAlways(31234, 0, pn, hp, max_hp);
                }

                ACS_ExecuteAlways(31235, 0);
            }
        }

        delay(1);
    }
}

script 31234 (int player, int hp, int max_hp) clientside {
    if (ConsolePlayerNumber() != player) terminate;

    if (max_hp < GetCVar("hpbar_min_maxhp")) terminate;
    int hp_percentage = hp * 100 / max_hp;

    if (has_target()) {
        str name = get_target_name();
        bool invul = get_target_invulerable();
        bool friendly = get_target_friendly();

        if (friendly && !GetCVar("hpbar_show_friendly")) terminate;

        int style = GetCVar("hpbar_style");
        if (style == STYLE_FULL) {
            show_full_hpbar(hp, max_hp, hp_percentage);

            SetHudSize(FULL_HUD_WIDTH, FULL_HUD_HEIGHT, true);
            SetFont("NORMAL");
            HudMessage(s: name; HUDMSG_FADEOUT, 6103, CR_WHITE, FULL_HPBAR_X, FULL_NAME_Y, FULL_HOLDTIME);
            int ln = 0;

            if (invul) {
                HudMessage(s: "\cgInvulnerable\c-"; HUDMSG_FADEOUT, 6104 + ln, CR_WHITE, FULL_HPBAR_X, FULL_INFO_Y + to_fixed(ln * 10), FULL_HOLDTIME);
                ++ln;
            }

            if (friendly) {
                HudMessage(s: "\c[x5]Friendly\c-"; HUDMSG_FADEOUT, 6104 + ln, CR_WHITE, FULL_HPBAR_X, FULL_INFO_Y + to_fixed(ln * 10), FULL_HOLDTIME);
                ++ln;
            }
        } else if (style == STYLE_MINIMAL) {
            show_minimal_hpbar(hp_percentage);
        }
    }
}

function void show_full_hpbar(int hp, int max_hp, int hp_percentage) {
    SetHudSize(FULL_HUD_WIDTH, FULL_HUD_HEIGHT, true);

    SetFont("NORMAL");
    HudMessage(d: hp, s: " / ", d: max_hp, s: " (", d: hp_percentage, s: "%)";
               HUDMSG_FADEOUT, 6000, CR_WHITE, FULL_HPBAR_X, FULL_HPBAR_Y, FULL_HOLDTIME);

    if (hp_percentage < 25)
        SetFont("FILLCRIT");
    else if (hp_percentage < 50)
        SetFont("FILLDAMG");
    else
        SetFont("FILLNORM");

    for (int i = 0; i <= 100 && i <= hp_percentage; ++i) {
        HudMessage(s: "A"; HUDMSG_FADEOUT , 6001 + i, CR_UNTRANSLATED, FULL_HPBAR_X - 97.0 + to_fixed(i * 2), FULL_HPBAR_Y, FULL_HOLDTIME);
    }

    SetFont("HPBAR");
    HudMessage(s: "A"; HUDMSG_FADEOUT, 6102, CR_UNTRANSLATED, FULL_HPBAR_X, FULL_HPBAR_Y, FULL_HOLDTIME);
}

function str hpp_to_color(int p) {
    if (p >= 100)
        return "\c[x5]";
    else if (p >= 75)
        return "\c[a6]";
    else if (p >= 50)
        return "\ck";
    else if (p >= 25)
        return "\c[o4]";

    return "\cr";
}

function void show_minimal_hpbar(int hp_percentage) {
    SetHudSize(MINIMAL_HUD_WIDTH, MINIMAL_HUD_HEIGHT, false);


    SetFont("NORMAL");
    HudMessage(s: hpp_to_color(hp_percentage), d: hp_percentage, s: "%\c-";
               HUDMSG_FADEOUT, 6000, CR_UNTRANSLATED, MINIMAL_HP_X, MINIMAL_HP_Y, MINIMAL_HOLDTIME, MINIMAL_FADETIME);
}

script "hpbar-open" open {
    for (int i = 0; i < MAX_TRACKERS; ++i) {
        tracked_tids[i] = INVALID_TID;
    }
}

script 31235 (void) {
    if (SetActivator(0, AAPTR_PLAYER_GETTARGET)) {
        // We only track monsters. :)
        if (!(ClassifyActor(0) & ACTOR_MONSTER)) terminate;

        if (GetActorProperty(0, APROP_SpawnHealth) < GetCVar("hpbar_server_tracker_threshold") && !is_boss(GetActorClass(0))) terminate;

        // Give it a new TID if it doesn't have one.
        int tid = ActivatorTID();
        if (tid == 0) {
            tid = UniqueTID(0, 0);
            Thing_ChangeTID(0, tid);
        }

        int i;
        for (int j = MAX_TRACKERS - 1; j >= 0; --j) {
            if (tracked_tids[j] == tid) {
                i = -1; // already tracked by another script
                break;
            } else if (tracked_tids[j] == INVALID_TID) {
                i = j;
            }
        }

        if (i == -1) terminate;

        tracked_tids[i] = tid;
        tracked_names[i] = pp_name(GetActorClass(0), GetActorProperty(0, APROP_NameTag));
        ACS_ExecuteAlways(31236, 0, i, tracked_tids[i]);
        while (ClassifyActor(tid) != ACTOR_NONE && (ClassifyActor(tid) & ACTOR_ALIVE)) {
            int old_hp = tracked_hps[i];
            int old_max_hp = tracked_max_hps[i];
            tracked_hps[i] = GetActorProperty(tid, APROP_Health);
            tracked_max_hps[i] = GetActorProperty(tid, APROP_SpawnHealth);
            if (old_hp != tracked_hps[i] || old_max_hp != tracked_max_hps[i]) {
                ACS_ExecuteAlways(31237, 0, i, tracked_hps[i], tracked_max_hps[i]);
            }
            delay(1);
        }

        tracked_tids[i] = INVALID_TID;
        ACS_ExecuteAlways(31236, 0, i, INVALID_TID);
    }
}

script 31236 (int i, int tid) clientside {
    if (tid == INVALID_TID) {
        tracked_tids[i] = tid;
    } else {
        if (ClassifyActor(0) != ACTOR_NONE) {
            tracked_tids[i] = tid;
            tracked_names[i] = pp_name(GetActorClass(0), GetActorProperty(0, APROP_NameTag));
        } else {
            tracked_tids[i] = INVALID_TID;
        }
    }
}

script 31237 (int i, int hp, int max_hp) clientside {
    if (max_hp != 0) {
        tracked_hps[i] = hp;
        tracked_max_hps[i] = max_hp;
    }
}

int maxhp_rankings[NUM_RANKINGS];

function bool already_selected(int x, int n) {
    for (int i = 0; i < n; ++i) {
        if (x == maxhp_rankings[i]) {
            return true;
        }
    }

    return false;
}

script 31238 (void) net {
    for (int i = 0; i < MAX_TRACKERS; ++i) {
        int tid = tracked_tids[i];
        if (tid != INVALID_TID) {
            SetActivator(tid);
            ACS_ExecuteAlways(31236, 0, i, tid);
            ACS_ExecuteAlways(31237, 0, i, tracked_hps[i], tracked_max_hps[i]);
        }
    }
}

script 31239 open clientside {
    for (int i = 0; i < MAX_TRACKERS; ++i) {
        tracked_tids[i] = INVALID_TID;
    }

    RequestScriptPuke(31238, 0, 0, 0);

    SetHudSize(1024, 768, false);
    while (true) {
        for (int rank = 0; rank < NUM_RANKINGS; ++rank) {
            int hp_limit = 0;
            int maxhp_limit = 0;

            maxhp_rankings[rank] = -1;

            for (i = 0; i < MAX_TRACKERS; ++i) {
                int tid = tracked_tids[i];
                if (tid != INVALID_TID) {
                    if (already_selected(i, rank)) continue;

                    int max_hp = tracked_max_hps[i];
                    int hp = tracked_hps[i];
                    if (max_hp > maxhp_limit) {
                        maxhp_rankings[rank] = i;
                        maxhp_limit = max_hp;
                        hp_limit = hp;
                    } else if (max_hp == maxhp_limit && hp > hp_limit) {
                        maxhp_rankings[rank] = i;
                        hp_limit = hp;
                    }
                }
            }

            int n = maxhp_rankings[rank];
            if (n == -1) break;

            hp = tracked_hps[n];
            max_hp = tracked_max_hps[n];
            int hpp = hp * 100 / max_hp;
            str name = tracked_names[n];
            HudMessage(s: hpp_to_color(hpp), d: hp, s: "/", d: max_hp, s: "\c-";
                       HUDMSG_FADEOUT, 7000 + rank, CR_WHITE, 80.2, 470.0 + rank * 12.0, 1.0 / 35 + 1, 0.1);
            HudMessage(s: hpp_to_color(hpp), d: hpp, s: "%\c-";
                       HUDMSG_FADEOUT, 7000 + NUM_RANKINGS + rank, CR_WHITE, 120.2, 470.0 + rank * 12.0, 1.0 / 35 + 1, 0.1);
            HudMessage(s: name;
                       HUDMSG_FADEOUT, 7000 + NUM_RANKINGS * 2 + rank, CR_WHITE, 132.1, 470.0 + rank * 12.0, 1.0 / 35 + 1, 0.1);
        }

        delay(1);
    }
}

script 31300 (void) {
    SetResultValue(SetActivator(0, AAPTR_PLAYER_GETTARGET));
}

function bool has_target(void) {
    return ACS_ExecuteWithResult(31300);
}

script 31301 (void) {
    if (SetActivator(0, AAPTR_PLAYER_GETTARGET)) {
        SetResultValue(GetActorProperty(0, APROP_Health));
    } else {
        SetResultValue(-1);
    }
}

function int get_target_health(void) {
    return ACS_ExecuteWithResult(31301);
}

script 31302 (void) {
    if (SetActivator(0, AAPTR_PLAYER_GETTARGET)) {
        SetResultValue(GetActorProperty(0, APROP_SpawnHealth));
    } else {
        SetResultValue(-1);
    }
}

function int get_target_spawn_health(void) {
    return ACS_ExecuteWithResult(31302);
}

script 31303 (void) {
    if (SetActivator(0, AAPTR_PLAYER_GETTARGET)) {
        SetResultValue(pp_name(GetActorClass(0), GetActorProperty(0, APROP_NameTag)));
    } else {
        SetResultValue(-1);
    }
}

function str get_target_name(void) {
    return ACS_ExecuteWithResult(31303);
}

script 31304 (void) {
    if (SetActivator(0, AAPTR_PLAYER_GETTARGET)) {
        SetResultValue(GetActorProperty(0, APROP_Invulnerable));
    } else {
        SetResultValue(-1);
    }
}

function bool get_target_invulerable(void) {
    return ACS_ExecuteWithResult(31304);
}

script 31305 (void) {
    if (SetActivator(0, AAPTR_PLAYER_GETTARGET)) {
        SetResultValue(GetActorProperty(0, APROP_Friendly));
    } else {
        SetResultValue(-1);
    }
}

function bool get_target_friendly(void) {
    return ACS_ExecuteWithResult(31305);
}

script 31306 (void) {
    if (SetActivator(0, AAPTR_PLAYER_GETTARGET)) {
        SetResultValue(ActivatorTID());
    } else {
        SetResultValue(-1);
    }
}

function bool get_target_tid(void) {
    return ACS_ExecuteWithResult(31306);
}

function int to_fixed(int x) {
    return x << 16;
}

// Return x is a case-insensitive prefix of y
function bool prefix_match(str x, str y) {
    return stricmp(x, y, strlen(y)) == 0;
}

function str pp_name(str class, str tag) {
    ////////////////////////////////////////////////////////////////////////////////
    // Complex Doom
    ////////////////////////////////////////////////////////////////////////////////
    if (prefix_match(class, "PlasmaGunner")) {
        return "Plasma Zombie";
    } else if (prefix_match(class, "Railgunner")) {
        return "Railgunner";
    } else if (prefix_match(class, "DemonTechZombie")) {
        return "Demon Tech Zombie";
    } else if (prefix_match(class, "RocketZombie")) {
        return "Rocket Zombie";
    } else if (prefix_match(class, "ShotgunZombie")) {
        return "Shotgunner";
    } else if (prefix_match(class, "AssaultShotgunZombie")) {
        return "Assault Shotgunner";
    } else if (prefix_match(class, "SuperShotgunZombie")) {
        return "Double Barrel Shotgun Zombie";
    } else if (prefix_match(class, "QuadShotgunZombie")) {
        return "\crQuad Barrel Shotgun Zombie\c-";
    } else if (prefix_match(class, "AssaultRifleZombie")) {
        return "Assault Rifle Zombie";
    // Chaingunner
    // Minigunner
    } else if (prefix_match(class, "BFGZombieman")) {
        return "BFG Zombie";
    // Imp
    } else if (prefix_match(class, "VoidImp")) {
        return "Void Imp";
    // Devil
    } else if (prefix_match(class, "PhaseImp")) {
        return "\ctPhase Imp\c-";
    } else if (prefix_match(class, "BullFiend")) {
        return "Bull Fiend";
    } else if (prefix_match(class, "CyberFiend")) {
        return "Cyber Fiend";
    } else if (prefix_match(class, "MagmaFiend")) {
        return "Magma Fiend";
    } else if (prefix_match(class, "DTechFiend")) {
        return "\cqDTech Fiend\c-";
    } else if (prefix_match(class, "Spectre~")) {
        return pp_name("Spectre", tag);
    // Lurker
    // Spook
    } else if (prefix_match(class, "TerrorSoul")) {
        return "Terror Soul";
    } else if (prefix_match(class, "ForgottenOne")) {
        return "Forgotten One";
    } else if (prefix_match(class, "PoisonSoul")) {
        return "Poison Soul";
    // Rictus
    } else if (prefix_match(class, "Cacodemon~")) {
        return pp_name("Cacodemon", tag);
    // Watcher
    // Cacomental
    } else if (prefix_match(class, "SoulKeeper")) {
        return "Soul Keeper";
    // Defiler
    } else if (prefix_match(class, "PoisonElemental")) {
        return "Poison Elemental";
    } else if (prefix_match(class, "BombElemental")) {
        return "Bomb Elemental";
    // Hectebus
    // Daedabus
    // Behemoth
    // Barbatos
    // Dualachnotron
    // Fusionite
    } else if (prefix_match(class, "BabyDemolisher")) {
        return "Baby Demolisher";
    } else if (prefix_match(class, "BabySentient")) {
        return "Baby Sentient";
    // Guardian
    // Cadaver
    } else if (prefix_match(class, "HellfireRevenant")) {
        return "Hellfire Revenant";
    // Famine
    } else if (prefix_match(class, "HellKnight~")) {
        return pp_name("HellKnight", tag);
    } else if (prefix_match(class, "PyroDemon")) {
        return "Pyro Demon";
    } else if (prefix_match(class, "CyberNoble")) {
        return "Cyber Noble";
    } else if (prefix_match(class, "HellDuke")) {
        return "\cdHell Duke\c-";
    } else if (prefix_match(class, "BaronOfHell~")) {
        return pp_name("BaronOfHell", tag);
    } else if (prefix_match(class, "BruiserDemon")) {
        return "BruiserDemon";
    // Cybruiser
    // Exile
    // Diabolist
    } else if (prefix_match(class, "DarkHellion")) {
        return "\cmDark Hellion\c-";
    // Demolisher
    } else if (prefix_match(class, "DarkDemolisher")) {
        return "\cqDark Demolisher\c-";
    } else if (prefix_match(class, "CerebralSentient")) {
        return "\cgCerebral Sentient\c-";
    } else if (prefix_match(class, "CyberLord")) {
        return "\cgCyberlord\c-";
    } else if (prefix_match(class, "DarkCyberdemon")) {
        return "\cqDark Cyberdemon\c-";
    } else if (prefix_match(class, "Cardinal")) {
        return "\cgDark Cardinal\c-";
    } else if (prefix_match(class, "SSNazi")) {
        return "SS Nazi";
    // Mutant
    // Officer
    } else if (prefix_match(class, "NaziDog")) {
        return "Nazi Guard Dog";
    // Hitler
    } else if (prefix_match(class, "HitlerNoSuit")) {
        return "Hitler";
    } else if (prefix_match(class, "DSP")) {
        return "Darksyde Phil";
    } else if (prefix_match(class, "ModdedExplosiveBarrel")) {
        return pp_name("ExplosiveBarrel", tag);
    } else if (prefix_match(class, "ComplexDoomPlayer")) {
        return pp_name("DoomPlayer", tag);
    }

    ////////////////////////////////////////////////////////////////////////////////
    // LCA
    ////////////////////////////////////////////////////////////////////////////////
    if (prefix_match(class, "BFG10KGeneral")) {
        return "\cdBFG10K General\c-";
    } else if (prefix_match(class, "BFGCacodemon")) {
        return "\cdBFG Cacodemon\c-";
    } else if (prefix_match(class, "Cardihilator")) {
        return "\cgCardihilator\c-";
    } else if (prefix_match(class, "CerebralCardinal")) {
        return "\cgCerebral Cardinal\c-";
    // Cydestroyer
    } else if (prefix_match(class, "Arcradimus")) {
        return "\c[z4]Demon Lord Arcradimus\c-";
    } else if (prefix_match(class, "DesertHornet")) {
        return "DesertHornet";
    } else if (prefix_match(class, "DTDevastatorZombie")) {
        return "\crDT Devastator Zombie\c-";
    } else if (prefix_match(class, "EraserZombie")) {
        return "\crEraser Zombie\c-";
    } else if (prefix_match(class, "Hexa-ShotgunZombie")) {
        return "\crHexa-Shotgun Zombie\c-";
    } else if (prefix_match(class, "FreezerBehemoth")) {
        return "\cvFreezer Behemoth\c-";
    } else if (prefix_match(class, "FreezerZombie")) {
        return "\cvFreezer Zombie\c-";
    } else if (prefix_match(class, "LegendaryAnnihilator")) {
        return "\c[z3]Legendary Annihilator\c-";
    } else if (prefix_match(class, "LegendaryAssaultCaptain")) {
        return "\c[z3]Legendary Assault Captain\c-";
    } else if (prefix_match(class, "LegendaryBabySentient")) {
        return "\c[z3]Legendary Baby Sentient\c-";
    } else if (prefix_match(class, "LegendaryBehemoth")) {
        return "\c[z3]Legendary Behemoth\c-";
    } else if (prefix_match(class, "LegendaryCardinal")) {
        return "\c[z3]Legendary Cardinal\c-";
    } else if (prefix_match(class, "LegendaryCommando")) {
        return "\c[z3]Legendary Commando\c-";
    } else if (prefix_match(class, "LegendaryCyberdemon")) {
        return "\c[z3]Legendary Cyberdemon\c-";
    } else if (prefix_match(class, "LegendaryCyberNoble")) {
        return "\c[z3]Legendary Cyber Noble\c-";
    } else if (prefix_match(class, "LegendaryFiend")) {
        return "\c[z3]Legendary Fiend\c-";
    } else if (prefix_match(class, "LegendaryHellKnight")) {
        return "\c[z3]Legendary Hell Knight\c-";
    } else if (prefix_match(class, "LegendaryImp")) {
        return "\c[z3]Legendary Imp\c-";
    } else if (prefix_match(class, "LegendaryRedeemer")) {
        return "\c[z3]Legendary Redeemer\c-";
    } else if (prefix_match(class, "LegendaryRevenant")) {
        return "\c[z3]Legendary Revenant\c-";
    } else if (prefix_match(class, "LegendarySentient")) {
        return "\c[z3]Legendary Sentient\c-";
    } else if (prefix_match(class, "LegendaryStealthTrooper")) {
        return "\c[z3]Legendary Stealth Trooper\c-";
    } else if (prefix_match(class, "LegZombie")) {
        return "\c[z3]Legendary Zombie\c-";
    } else if (prefix_match(class, "PhaseOverlord")) {
        return "\ctPhase Overlord\c-";
    } else if (prefix_match(class, "SandSpirit")) {
        return "\ceSand Spirit\c-";
    } else if (prefix_match(class, "ShotgunCommando")) {
        return "Shotgun Commando";
    } else if (prefix_match(class, "TrueLegendaryCyberdemon")) {
        return "\c[l5]True\c- \c[z3]Legendary Cyberdemon\c-";
    } else if (prefix_match(class, "TrueLegendaryCardinal")) {
        return "\c[l5]True\c- \c[z3]Legendary Cardinal\c-";
    } else if (prefix_match(class, "Velocirator")) {
        return "\cdVelocirator\c-";

    // lca's edited complex monsters
    } else if (prefix_match(class, "NewBabySentient")) {
        return pp_name("BabySentient", tag);
    } else if (prefix_match(class, "NewBehemoth")) {
        return pp_name("Behemoth", tag);
    } else if (prefix_match(class, "NewCerebralSentient")) {
        return pp_name("CerebralSentient", tag);
    }


    ////////////////////////////////////////////////////////////////////////////////
    // Random Monsters
    ////////////////////////////////////////////////////////////////////////////////
    // Abaddon
    // Afrit
    if (prefix_match(class, "BabyDDemolisher")) {
        return "\cqBaby Dark Demolisher\c-";
    // Demobus
    } else if (prefix_match(class, "BFGMastermind")) {
        return "BFG Mastermind";
    } else if (prefix_match(class, "CacoLich")) {
        return "Cacolich";
    } else if (prefix_match(class, "CerebralCommander")) {
        return "\cgCerebral Commander\c-";
    } else if (prefix_match(class, "ChaingunFiend")) {
        return "Chaingun Fiend";
    } else if (prefix_match(class, "CorruptedCyberLord")) {
        return "\c[l5]Corrupted Annihilator\c-";
    } else if (prefix_match(class, "CryoDemon")) {
        return "Cyro Demon";
    } else if (prefix_match(class, "CryoImp")) {
        return "Cyro Imp";
    } else if (prefix_match(class, "DTShotgunZombie")) {
        return "Demon Tech Shotgunner";
    } else if (prefix_match(class, "DTechSpider")) {
        return "Demon Tech Spider";
    } else if (prefix_match(class, "DemonTechTrooper")) {
        return "Demon Tech Trooper";
    } else if (prefix_match(class, "EMinigunner")) {
        return "Explosive Minigunner";
    } else if (prefix_match(class, "SSRocketMan")) {
        return "SS Rocket Man";
    } else if (prefix_match(class, "SSSuperSolider")) {
        return "SS Super Solider";
    } else if (prefix_match(class, "HellArchon")) {
        return "Hell Archon";
    } else if (prefix_match(class, "HellFireBaron")) {
        return "\cgHellfire Baron\c-";
    } else if (prefix_match(class, "HellFireCyberdemon")) {
        return "\c[z4]Hellfire Cyberdemon\c-";
    } else if (prefix_match(class, "HomingRocketZombie")) {
        return "Homing Rocket Zombie";
    } else if (prefix_match(class, "ImpLord")) {
        return "\crImp Lord\c-";
    // Infected
    } else if (prefix_match(class, "SuicideBomber")) {
        return "Suicide Bomber";
    } else if (prefix_match(class, "KSBehemoth")) {
        return pp_name("Behemoth", tag);
    } else if (prefix_match(class, "NewBarbatos")) {
        return pp_name("Barbatos", tag);
    } else if (prefix_match(class, "PhaseElemental")) {
        return "\ctPhaseElemental\c-";
    } else if (prefix_match(class, "PhaseSoul")) {
        return "\ctPhase Soul\c-";
    } else if (prefix_match(class, "PhaseWarlord")) {
        return "\ctPhase Warlord\c-";
    } else if (prefix_match(class, "PistolZombie")) {
        return "Pistol Zombie";
    } else if (prefix_match(class, "ProtoDestroyer")) {
        return "\cgProto-Destroyer\c-";
    } else if (prefix_match(class, "PyroImp")) {
        return "Pyro Imp";
    } else if (prefix_match(class, "Terminator2")) {
        return "\crTerminator\c-";
    } else if (prefix_match(class, "ToxicImp")) {
        return "Toxic Imp";
    } else if (prefix_match(class, "ToxicLord")) {
        return "\cdToxic Lord\c-";
    } else if (prefix_match(class, "WidowMaker")) {
        return "Widow Maker";
    }

    ////////////////////////////////////////////////////////////////////////////////
    // HAF
    ////////////////////////////////////////////////////////////////////////////////
    if (prefix_match(class, "DementedTerminator")) {
        return "\c[o7]Demented\c- \crTerminator\c-";
    }

    ////////////////////////////////////////////////////////////////////////////////
    // Ark
    ////////////////////////////////////////////////////////////////////////////////
    if (prefix_match(class, "ComplexCardinal")) {
        return pp_name("Cardinal", tag);
    } else if (prefix_match(class, "BlueCardinal")) {
        return "\c[l5]Corrupted Cardinal\c-";
    } else if (prefix_match(class, "ArkMarine")) {
        return pp_name("DoomPlayer", tag);
    }

    ////////////////////////////////////////////////////////////////////////////////
    // Insane LCA
    ////////////////////////////////////////////////////////////////////////////////
    if (prefix_match(class, "EnragedLegZombie")) {
        return "\c[m6]Enraged\c- \c[z3]Legendary Zombie\c-";
    } else if (prefix_match(class, "EnragedLegendaryImp")) {
        return "\c[m6]Enraged\c- \c[z3]Legendary Imp\c-";
    } else if (prefix_match(class, "EnragedLegendaryAssaultCaptain")) {
        return "\c[m6]Enraged\c- \c[z3]Legendary Assault Captain\c-";
    } else if (prefix_match(class, "EnragedLegendaryRevenant")) {
        return "\c[m6]Enraged\c- \c[z3]Legendary Revenant\c-";
    }

    ////////////////////////////////////////////////////////////////////////////////
    // RGA2
    ////////////////////////////////////////////////////////////////////////////////

    if (prefix_match(class, "RGUPlayer")) {
        return pp_name("DoomPlayer", tag);
    } else if (prefix_match(class, "RGULastStandPlayer")) {
        return pp_name("DoomPlayer", tag);
    }

    ////////////////////////////////////////////////////////////////////////////////
    // Doge class!
    ////////////////////////////////////////////////////////////////////////////////
    if (prefix_match(class, "Doge")) {
        return "\c[c5]DOGE\c-";
    }

    ////////////////////////////////////////////////////////////////////////////////
    // Original Doom Monsters (fallback)
    ////////////////////////////////////////////////////////////////////////////////

    // Doom
    if (prefix_match(class, "ZombieMan")) {
        return "Former Human";
    } else if (prefix_match(class, "ShotgunGuy")) {
        return "Former Human Sergeant";
    } else if (prefix_match(class, "DoomImp")) {
        return "Imp";
    } else if (prefix_match(class, "Demon")) {
        return "Demon";
    } else if (prefix_match(class, "Spectre")) {
        return "Spectre";
    } else if (prefix_match(class, "LostSoul")) {
        return "Lost Soul";
    } else if (prefix_match(class, "Cacodemon")) {
        return "Cacodemon";
    } else if (prefix_match(class, "BaronOfHell")) {
        return "Baron Of Hell";
    } else if (prefix_match(class, "Cyberdemon")) {
        return "Cyberdemon";
    } else if (prefix_match(class, "SpiderMastermind")) {
        return "Spider Mastermind";

    // Doom 2
    } else if (prefix_match(class, "ChaingunGuy")) {
        return "Heavy Weapon Dude";
    } else if (prefix_match(class, "HellKnight")) {
        return "Hell Knight";
    } else if (prefix_match(class, "Revenant")) {
        return "Revenant";
    } else if (prefix_match(class, "Fatso")) {
        return "Mancubus";
    } else if (prefix_match(class, "Arachnotron")) {
        return "Arachnotron";
    } else if (prefix_match(class, "PainElemental")) {
        return "Pain Elemental";
    } else if (prefix_match(class, "Archvile")) {
        return "Arch-vile";
    } else if (prefix_match(class, "WolfensteinSS")) {
        return "Wolfenstein SS";
    } else if (prefix_match(class, "CommanderKeen")) {
        return "Commander Keen";
    } else if (prefix_match(class, "BossBrain")) {
        return "John Romero";
    } else if (prefix_match(class, "ExplosiveBarrel")) {
        return "\cgExplosive Barrel\c-";
    } else if (prefix_match(class, "DoomPlayer")) {
        return pp_name("\c[x5]Player\c-", tag);
    // DOGE!
    } else if (prefix_match(class, "MBFHelperDog")) {
        return pp_name("Doge", tag);
    }

    return tag;
}

// Ideally, we should check whether the BOSS flag is set on the actor, but it isn't supported in Zandronum 2.1.2 yet. So we simply whitelist most common bosses in popular WADs.
function bool is_boss(str name) {
    // Complex
    if (prefix_match(name, "DarkHellion")) {
        return true;
    } else if (prefix_match(name, "Demolisher")) {
        return true;
    } else if (prefix_match(name, "DarkDemolisher")) {
        return true;
    } else if (prefix_match(name, "CerebralSentient")) {
        return true;
    } else if (prefix_match(name, "CyberLord")) {
        return true;
    } else if (prefix_match(name, "DarkCyberdemon")) {
        return true;
    } else if (prefix_match(name, "Cardinal")) {
        return true;
    } else if (prefix_match(name, "Hitler")) {
        return true;
    }

    // LCA
    if (prefix_match(name, "Cardihilator")) {
        return true;
    } else if (prefix_match(name, "CerebralCardinal")) {
        return true;
    } else if (prefix_match(name, "LegendaryAnnihilator")) {
        return true;
    } else if (prefix_match(name, "LegendaryAssaultCaptain")) {
        return true;
    } else if (prefix_match(name, "LegendaryBabySentient")) {
        return true;
    } else if (prefix_match(name, "LegendaryBehemoth")) {
        return true;
    } else if (prefix_match(name, "LegendaryCardinal")) {
        return true;
    } else if (prefix_match(name, "LegendaryCommando")) {
        return true;
    } else if (prefix_match(name, "LegendaryCyberdemon")) {
        return true;
    } else if (prefix_match(name, "LegendaryCyberNoble")) {
        return true;
    } else if (prefix_match(name, "LegendaryFiend")) {
        return true;
    } else if (prefix_match(name, "LegendaryHellKnight")) {
        return true;
    } else if (prefix_match(name, "LegendaryImp")) {
        return true;
    } else if (prefix_match(name, "LegendaryRedeemer")) {
        return true;
    } else if (prefix_match(name, "LegendaryRevenant")) {
        return true;
    } else if (prefix_match(name, "LegendarySentient")) {
        return true;
    } else if (prefix_match(name, "LegendaryStealthTrooper")) {
        return true;
    } else if (prefix_match(name, "LegZombie")) {
        return true;
    } else if (prefix_match(name, "TrueLegendaryCyberdemon")) {
        return true;
    } else if (prefix_match(name, "TrueLegendaryCardinal")) {
        return true;
    } else if (prefix_match(name, "Velocirator")) {
        return true;
    }

    // Randommons
    if (prefix_match(name, "BFGMastermind")) {
        return true;
    } else if (prefix_match(name, "CerebralCommander")) {
        return true;
    } else if (prefix_match(name, "CorruptedCyberLord")) {
        return true;
    } else if (prefix_match(name, "HellFireBaron")) {
        return true;
    } else if (prefix_match(name, "HellFireCyberdemon")) {
        return true;
    } else if (prefix_match(name, "PhaseWarlord")) {
        return true;
    } else if (prefix_match(name, "Terminator2")) {
        return true;
    }

    // HAF
    if (prefix_match(name, "DementedTerminator")) {
        return true;
    }

    // Ark
    if (prefix_match(name, "ComplexCardinal")) {
        return true;
    } else if (prefix_match(name, "BlueCardinal")) {
        return true;
    }

    // Insane LCA
    if (prefix_match(name, "EnragedLegZombie")) {
        return true;
    } else if (prefix_match(name, "EnragedLegendaryImp")) {
        return true;
    } else if (prefix_match(name, "EnragedLegendaryAssaultCaptain")) {
        return true;
    } else if (prefix_match(name, "EnragedLegendaryRevenant")) {
        return true;
    }

    // RGA2
    if (prefix_match(name, "StoneAbaddon")) {
        return true;
    } else if (prefix_match(name, "SuperRevenant")) {
        return true;
    } else if (prefix_match(name, "Deathvile")) {
        return true;
    } else if (prefix_match(name, "ArachnidOverlord")) {
        return true;
    } else if (prefix_match(name, "Cyberlord")) {
        return true;
    }

    // Doom
    if (prefix_match(name, "Archvile")) {
        return true;
    } else if (prefix_match(name, "Cyberdemon")) {
        return true;
    } else if (prefix_match(name, "SpiderMastermind")) {
        return true;
    }

    return false;
}

// vim: set ft=c:
