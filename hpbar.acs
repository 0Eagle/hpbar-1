#library "hpbar"
#include "zcommon.acs"

#define STYLE_FULL    1
#define STYLE_MINIMAL 2

#define FULL_HUD_WIDTH  800
#define FULL_HUD_HEIGHT 600
#define FULL_HOLDTIME 0.25
#define FULL_HPBAR_X 400.0
#define FULL_HPBAR_Y 40.0
#define FULL_NAME_Y  (FULL_HPBAR_Y + 25.0)
#define FULL_INFO_Y  (FULL_NAME_Y + 12.0)

#define MINIMAL_HUD_WIDTH  1280
#define MINIMAL_HUD_HEIGHT 960
#define MINIMAL_HOLDTIME ((1.0 / 35) + 1)
#define MINIMAL_FADETIME 0.1
#define MINIMAL_HP_X 640.0
#define MINIMAL_HP_Y 500.0

script "hpbar-enter" enter {
    int pn = PlayerNumber();

    while (true) {
        if (has_target()) {
            int hp = get_target_health();
            int max_hp = get_target_spawn_health();
            if (max_hp <= 0) max_hp = hp;
            if (max_hp > 0) {
                if (max_hp >= GetCVar("hpbar_threshold")) {
                    SetCVarString(strparam(s: "hpbar_target_name", d: pn), get_target_name());
                    ACS_ExecuteAlways(31234, 0, pn, hp, max_hp);
                }

                ACS_ExecuteAlways(31235, 0);
            }
        }

        delay(1);
    }
}

script 31234 (int player, int hp, int max_hp) clientside {
    if (ConsolePlayerNumber() != player) terminate;

    int hp_percentage = hp * 100 / max_hp;

    if (has_target()) {
        str name = GetCVarString(strparam(s: "hpbar_target_name", d: ConsolePlayerNumber()));
        bool invul = get_target_invulerable();
        bool friendly = get_target_friendly();

        if (friendly && !GetCVar("hpbar_show_friendly")) terminate;

        int style = GetCVar("hpbar_style");
        if (style == STYLE_FULL) {
            show_full_hpbar(hp, max_hp, hp_percentage);

            SetHudSize(FULL_HUD_WIDTH, FULL_HUD_HEIGHT, true);
            SetFont("NORMAL");
            HudMessage(s: name; HUDMSG_FADEOUT, 6103, CR_WHITE, FULL_HPBAR_X, FULL_NAME_Y, FULL_HOLDTIME);
            int ln = 0;

            if (invul) {
                HudMessage(s: "\c[i8]Invulnerable\c-"; HUDMSG_FADEOUT, 6104 + ln, CR_WHITE, FULL_HPBAR_X, FULL_INFO_Y + to_fixed(ln * 10), FULL_HOLDTIME);
                ++ln;
            }

            if (friendly) {
                HudMessage(s: "\c[x5]Friendly\c-"; HUDMSG_FADEOUT, 6104 + ln, CR_WHITE, FULL_HPBAR_X, FULL_INFO_Y + to_fixed(ln * 10), FULL_HOLDTIME);
                ++ln;
            }
        } else if (style == STYLE_MINIMAL) {
            show_minimal_hpbar(hp_percentage);
        }
    }
}

function void show_full_hpbar(int hp, int max_hp, int hp_percentage) {
    SetHudSize(FULL_HUD_WIDTH, FULL_HUD_HEIGHT, true);

    SetFont("NORMAL");
    HudMessage(d: hp, s: " / ", d: max_hp, s: " (", d: hp_percentage, s: "%)";
               HUDMSG_FADEOUT, 6000, CR_WHITE, FULL_HPBAR_X, FULL_HPBAR_Y, FULL_HOLDTIME);

    if (hp_percentage < 25)
        SetFont("FILLCRIT");
    else if (hp_percentage < 50)
        SetFont("FILLDAMG");
    else
        SetFont("FILLNORM");

    for (int i = 0; i <= 100 && i <= hp_percentage; ++i) {
        HudMessage(s: "A"; HUDMSG_FADEOUT , 6001 + i, CR_UNTRANSLATED, FULL_HPBAR_X - 97.0 + to_fixed(i * 2), FULL_HPBAR_Y, FULL_HOLDTIME);
    }

    SetFont("HPBAR");
    HudMessage(s: "A"; HUDMSG_FADEOUT, 6102, CR_UNTRANSLATED, FULL_HPBAR_X, FULL_HPBAR_Y, FULL_HOLDTIME);
}

function str hpp_to_color(int p) {
    if (p >= 100)
        return "\c[x5]";
    else if (p >= 75)
        return "\c[a6]";
    else if (p >= 50)
        return "\ck";
    else if (p >= 25)
        return "\c[o4]";

    return "\cr";
}

function void show_minimal_hpbar(int hp_percentage) {
    SetHudSize(MINIMAL_HUD_WIDTH, MINIMAL_HUD_HEIGHT, false);

    SetFont("NORMAL");
    HudMessage(s: hpp_to_color(hp_percentage), d: hp_percentage, s: "%\c-";
               HUDMSG_FADEOUT, 6000, CR_UNTRANSLATED, MINIMAL_HP_X, MINIMAL_HP_Y, MINIMAL_HOLDTIME, MINIMAL_FADETIME);
}

#define MAX_TRACKERS 32
#define NUM_RANKINGS 10
// This should be -1, but Zandronum 2.1.2 has a bug where ACS_ExecuteAlways would send -1 as 255! WTF?!!!
#define INVALID_TID (-129)

int tracked_tids[MAX_TRACKERS];
int tracked_hps[MAX_TRACKERS];
int tracked_max_hps[MAX_TRACKERS];
bool tracked_invul[MAX_TRACKERS];

script "hpbar-open" open {
    for (int i = 0; i < MAX_TRACKERS; ++i) {
        tracked_tids[i] = INVALID_TID;
    }
}

script 31235 (void) {
    if (SetActivator(0, AAPTR_PLAYER_GETTARGET)) {
        // We only track monsters. :)
        if (!(ClassifyActor(0) & ACTOR_MONSTER)) terminate;

        // Should we track it?
        if (GetActorProperty(0, APROP_SpawnHealth) < GetCVar("hpbar_tracker_threshold") && !is_boss(GetActorClass(0))) terminate;

        // Give it a new TID if it doesn't have one.
        int tid = ActivatorTID();
        if (tid == 0) {
            tid = UniqueTID(0, 0);
            Thing_ChangeTID(0, tid);
        }

        // Find an empty slot for this monster and check if it is already tracked.
        int i;
        for (int j = MAX_TRACKERS - 1; j >= 0; --j) {
            if (tracked_tids[j] == tid) {
                terminate; // already tracked by another script
            } else if (tracked_tids[j] == INVALID_TID) {
                i = j;
            }
        }

        // Add tid to the slot and tell clients to track this activator.
        tracked_tids[i] = tid;
        ACS_ExecuteAlways(31236, 0, i, tracked_tids[i]);

        tracked_max_hps[i] = GetActorProperty(0, APROP_SpawnHealth);
        str name_cvar = strparam(s: "hpbar_tracked_names", d: i);

        // Keep updating clients the HP and name of the monster while it is alive.
        while (ClassifyActor(0) & ACTOR_ALIVE) {
            // Send monster HP
            int old_hp = tracked_hps[i];
            tracked_hps[i] = GetActorProperty(0, APROP_Health);
            if (old_hp != tracked_hps[i]) {
                ACS_ExecuteAlways(31237, 0, i, tracked_hps[i]);
            }

            tracked_invul[i] = GetActorProperty(0, APROP_Invulnerable);

            // Send name of monster
            str old_name = GetCVarString(name_cvar);
            str name = get_actor_name(0);
            if (old_name == 0 || !streq(old_name, name)) {
                SetCVarString(name_cvar, name);
            }

            delay(1);
        }

        // The monster is dead, remove it from the slot and tell clients to stop tracking it.
        tracked_tids[i] = INVALID_TID;
        SetCVarString(strparam(s: "hpbar_tracked_names", d: i), "");
        ACS_ExecuteAlways(31236, 0, i, INVALID_TID);
    }
}

script 31236 (int i, int tid) clientside {
    if (tid == INVALID_TID) {
        tracked_tids[i] = tid;
    } else {
        if (ClassifyActor(0) & ACTOR_ALIVE) {
            tracked_tids[i] = tid;
            tracked_max_hps[i] = GetActorProperty(0, APROP_SpawnHealth);
            while (ClassifyActor(0) & ACTOR_ALIVE) {
                tracked_invul[i] = GetActorProperty(0, APROP_Invulnerable);
                delay(1);
            }
        } else {
            tracked_tids[i] = INVALID_TID;
        }
    }
}

script 31237 (int i, int hp) clientside {
    tracked_hps[i] = hp;
}

script 31238 (void) net {
    for (int i = 0; i < MAX_TRACKERS; ++i) {
        int tid = tracked_tids[i];
        if (tid != INVALID_TID) {
            SetActivator(tid);
            SetCVarString(strparam(s: "hpbar_tracked_names", d: i), get_actor_name(0));
            ACS_ExecuteAlways(31236, 0, i, tid);
            ACS_ExecuteAlways(31237, 0, i, tracked_hps[i]);
        }
    }
}

function void request_broadcast_tracker_info(void) {
    RequestScriptPuke(31238, 0, 0, 0);
}

int maxhp_rankings[NUM_RANKINGS];

function bool already_selected(int x, int n) {
    for (int i = 0; i < n; ++i) {
        if (x == maxhp_rankings[i]) {
            return true;
        }
    }

    return false;
}

script 31239 open clientside {
    for (int i = 0; i < MAX_TRACKERS; ++i) {
        tracked_tids[i] = INVALID_TID;
    }

    request_broadcast_tracker_info();

    SetHudSize(1024, 768, false);
    while (true) {
        int x = to_fixed(GetCVar("hpbar_tracker_x"));
        int y = to_fixed(GetCVar("hpbar_tracker_y"));
        for (int rank = 0; rank < NUM_RANKINGS; ++rank) {
            int hp_limit = 0;
            int maxhp_limit = 0;

            maxhp_rankings[rank] = -1;

            for (i = 0; i < MAX_TRACKERS; ++i) {
                int tid = tracked_tids[i];
                if (tid != INVALID_TID) {
                    if (already_selected(i, rank)) continue;

                    int max_hp = tracked_max_hps[i];
                    int hp = tracked_hps[i];
                    if (max_hp > maxhp_limit) {
                        maxhp_rankings[rank] = i;
                        maxhp_limit = max_hp;
                        hp_limit = hp;
                    } else if (max_hp == maxhp_limit && hp > hp_limit) {
                        maxhp_rankings[rank] = i;
                        hp_limit = hp;
                    }
                }
            }

            int n = maxhp_rankings[rank];
            if (n == -1) break;

            hp = tracked_hps[n];
            max_hp = tracked_max_hps[n];
            int hpp = hp * 100 / max_hp;
            str name = GetCVarString(strparam(s: "hpbar_tracked_names", d: n));
            HudMessage(s: hpp_to_color(hpp), d: hp, s: "/", d: max_hp, s: "\c-";
                       HUDMSG_FADEOUT, 7000 + rank, CR_WHITE, x + 80.2, y + rank * 12.0, 1.0 / 35 + 1, 0.1);
            HudMessage(s: hpp_to_color(hpp), d: hpp, s: "%\c-";
                       HUDMSG_FADEOUT, 7000 + NUM_RANKINGS + rank, CR_WHITE, x + 120.2, y + rank * 12.0, 1.0 / 35 + 1, 0.1);

            str invulmsg = "";
            if (tracked_invul[n])
                invulmsg = " \c[i8][INVUL]\c-";

            HudMessage(s: name, s: invulmsg;
                       HUDMSG_FADEOUT, 7000 + NUM_RANKINGS * 2 + rank, CR_WHITE, x + 132.1, y + rank * 12.0, 1.0 / 35 + 1, 0.1);
        }

        delay(1);
    }
}

script 31300 (void) {
    SetResultValue(SetActivator(0, AAPTR_PLAYER_GETTARGET));
}

function bool has_target(void) {
    return ACS_ExecuteWithResult(31300);
}

script 31301 (void) {
    if (SetActivator(0, AAPTR_PLAYER_GETTARGET)) {
        SetResultValue(GetActorProperty(0, APROP_Health));
    } else {
        SetResultValue(-1);
    }
}

function int get_target_health(void) {
    return ACS_ExecuteWithResult(31301);
}

script 31302 (void) {
    if (SetActivator(0, AAPTR_PLAYER_GETTARGET)) {
        SetResultValue(GetActorProperty(0, APROP_SpawnHealth));
    } else {
        SetResultValue(-1);
    }
}

function int get_target_spawn_health(void) {
    return ACS_ExecuteWithResult(31302);
}

script 31303 (void) {
    if (SetActivator(0, AAPTR_PLAYER_GETTARGET)) {
        SetResultValue(get_actor_name(0));
    } else {
        SetResultValue(-1);
    }
}

function str get_target_name(void) {
    return ACS_ExecuteWithResult(31303);
}

script 31304 (void) {
    if (SetActivator(0, AAPTR_PLAYER_GETTARGET)) {
        SetResultValue(GetActorProperty(0, APROP_Invulnerable));
    } else {
        SetResultValue(-1);
    }
}

function bool get_target_invulerable(void) {
    return ACS_ExecuteWithResult(31304);
}

script 31305 (void) {
    if (SetActivator(0, AAPTR_PLAYER_GETTARGET)) {
        SetResultValue(GetActorProperty(0, APROP_Friendly));
    } else {
        SetResultValue(-1);
    }
}

function bool get_target_friendly(void) {
    return ACS_ExecuteWithResult(31305);
}

script 31306 (void) {
    if (SetActivator(0, AAPTR_PLAYER_GETTARGET)) {
        SetResultValue(ActivatorTID());
    } else {
        SetResultValue(-1);
    }
}

function bool get_target_tid(void) {
    return ACS_ExecuteWithResult(31306);
}

function int to_fixed(int x) {
    return x << 16;
}

function str get_actor_name(int tid) {
    str class = GetActorClass(tid);
    str name = GetCVarString(strparam(s: "hpbar_name_", s: class));
    if (name != 0) {
        return name;
    }

    name = GetCVarString(strparam(s: "hpbar_name_", s: normalize_class(class)));
    if (name != 0) {
        return name;
    }

    return GetActorProperty(tid, APROP_NameTag);
}

// Ideally, we should check whether the BOSS flag is set on the actor, but it isn't supported in Zandronum 2.1.2 yet. So we simply whitelist most common bosses in popular WADs.
function bool is_boss(str class) {
    bool boss = GetCVar(strparam(s: "hpbar_track_", s: class));
    if (boss) {
        return true;
    }

    boss = GetCVar(strparam(s: "hpbar_track_", s: normalize_class(class)));
    if (boss) {
        return true;
    }

    return false;
}

function bool streq(str x, str y) {
    return strcmp(x, y) == 0;
}

function str normalize_class(str class) {
    // These can't be declared as cvars due to special characters, so we special case them here:
    if (streq(class, "Spectre~")) { return "Spectre"; }
    if (streq(class, "Cacodemon~")) { return "Cacodemon"; }
    if (streq(class, "HellKnight~")) { return "HellKnight"; }
    if (streq(class, "BaronOfHell~")) { return "BaronOfHell"; }
    if (streq(class, "Hexa-ShotgunZombie")) { return "HexaShotgunZombie"; }

    // HEM
    if (streq(class, "Hades-TechZombie")) { return "HadesTechZombie"; }

    str s = GetCVarString(strparam(s: "hpbar_map_", s: class));
    if (s != 0) {
        return s;
    }

    return class;
}

// vim: set ft=c:
